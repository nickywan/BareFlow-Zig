# Phase 4: Bare-Metal LLVM Integration Plan

**Date**: 2025-10-26
**Status**: ‚úÖ LLVM 18 Validated - Ready to Start
**Goal**: Integrate FULL LLVM 18 (545MB) into bare-metal unikernel

---

## üéØ Validation Complete!

### ‚úÖ LLVM 18 Installation Verified

```
LLVM Version: 18.1.8
Installation size: 545MB total (420MB libs) - COMPLETE!
Components: 220 available
```

**Key Components Working**:
- ‚úÖ Interpreter (for universal profiling)
- ‚úÖ OrcJIT (for dynamic compilation)
- ‚úÖ JitLink (for linking JIT code)
- ‚úÖ X86 backend (target architecture)
- ‚úÖ ALL optimization passes (O0‚ÜíO1‚ÜíO2‚ÜíO3)

**Test Results**: `tests/phase3/test_llvm_validation.cpp`
- OrcJIT compilation: ‚úÖ PASS
- Function execution: ‚úÖ PASS (fib(10) = 55)
- Ready for bare-metal integration: ‚úÖ YES

---

## üöÄ Integration Strategy

### Philosophy Reminder

```
‚ö†Ô∏è CRITICAL: Use FULL LLVM (545MB), NOT minimal build!

Boot 1:     [545MB]  FULL LLVM + app IR  ‚Üí Profile everything
            ‚Üì Auto-profiling universel
Boot 100:   [100MB]  Hot paths JIT O0‚ÜíO3
            ‚Üì Auto-optimization
Boot 500:   [30MB]   Dead code √©limin√©
            ‚Üì Convergence progressive
Boot 1000:  [5-10MB] Pure native export
```

**Size is NOT a constraint - convergence is everything!**

---

## üìã Implementation Phases

### Phase 4.1: Static Linking Approach (Weeks 1-2)

**Goal**: Create single 545MB bootable image with LLVM embedded

**Strategy**: Link LLVM statically into kernel
```bash
# Compile kernel with LLVM libraries
clang-18 -m32 -ffreestanding -nostdlib \
    kernel/*.c kernel/*.asm \
    -L/usr/lib/llvm-18/lib \
    -lLLVMCore -lLLVMSupport -lLLVMOrcJIT \
    -lLLVMX86CodeGen -lLLVMX86Desc -lLLVMX86Info \
    ... (all 213 libraries)
    -o kernel.bin
```

**Challenges**:
1. **C++ Runtime**: LLVM requires C++ stdlib, exceptions, RTTI
2. **System Calls**: LLVM expects malloc, pthread, etc.
3. **32-bit**: Must compile LLVM for i686 target
4. **Size**: 545MB kernel binary

**Solutions**:
1. Implement C++ runtime stubs in kernel_lib
2. Provide custom allocator, no threads initially
3. Use -m32 for all LLVM libraries
4. Bootloader extended to load 545MB

**Tasks**:
- [ ] Build LLVM 18 as 32-bit static libraries
- [ ] Implement C++ runtime minimal stubs
- [ ] Create custom allocator for JIT
- [ ] Link kernel with LLVM libraries
- [ ] Test boot with 545MB image

---

### Phase 4.2: JIT Interface (Week 3)

**Goal**: C wrapper for bare-metal LLVM usage

**Architecture**:
```c
// kernel_lib/llvm_baremental.h (C interface)
typedef struct llvm_context llvm_context_t;
typedef struct llvm_module llvm_module_t;
typedef struct llvm_function llvm_function_t;

llvm_context_t* llvm_init(void);
llvm_module_t* llvm_parse_ir(llvm_context_t* ctx, const char* ir, size_t len);
llvm_function_t* llvm_jit_compile(llvm_module_t* mod, const char* func_name, int opt_level);
void* llvm_get_function_ptr(llvm_function_t* func);
void llvm_shutdown(llvm_context_t* ctx);
```

```cpp
// kernel_lib/llvm_baremetal.cpp (C++ implementation)
extern "C" {
    llvm_context_t* llvm_init() {
        // Initialize LLVM, return opaque pointer to LLVMContext
    }

    llvm_module_t* llvm_parse_ir(llvm_context_t* ctx, const char* ir, size_t len) {
        // Parse IR string to Module
    }

    llvm_function_t* llvm_jit_compile(llvm_module_t* mod, const char* func_name, int opt_level) {
        // Use OrcJIT to compile with O0/O1/O2/O3
    }
}
```

**Tasks**:
- [ ] Design C interface for LLVM
- [ ] Implement wrapper in C++
- [ ] Test with simple IR functions
- [ ] Validate O0‚ÜíO3 optimization

---

### Phase 4.3: Kernel Integration (Week 4)

**Goal**: Kernel boots, loads IR, runs Interpreter

**Boot Sequence**:
```
1. BIOS loads Stage 1 (512B) at 0x7C00
2. Stage 1 loads Stage 2 (4KB) at 0x7E00
3. Stage 2 loads Kernel+LLVM (545MB) at 0x100000
4. Stage 2 verifies "FLUD" signature
5. Stage 2 jumps to kernel entry
6. Kernel initializes LLVM runtime
7. Kernel loads embedded IR from .rodata
8. Kernel executes IR with Interpreter
```

**Memory Layout**:
```
0x0000 - 0x7BFF:   BIOS data, IVT
0x7C00 - 0x7DFF:   Stage 1 (512B)
0x7E00 - 0x8DFF:   Stage 2 (4KB)
0x9000 - 0x9FFF:   Stack (4KB)
0x100000+:         Kernel+LLVM+IR (545MB)
  ‚îú‚îÄ‚îÄ .text:       Kernel code
  ‚îú‚îÄ‚îÄ .llvm:       LLVM libraries (420MB)
  ‚îú‚îÄ‚îÄ .ir:         Application IR (~100KB)
  ‚îî‚îÄ‚îÄ .data/.bss:  Kernel data
```

**Embedded IR**:
```c
// Generated by build system
extern uint8_t _binary_app_ll_start[];
extern uint8_t _binary_app_ll_end[];

void kernel_main() {
    llvm_context_t* llvm = llvm_init();
    size_t ir_size = _binary_app_ll_end - _binary_app_ll_start;
    llvm_module_t* mod = llvm_parse_ir(llvm, (char*)_binary_app_ll_start, ir_size);

    // Execute with Interpreter
    llvm_function_t* main_func = llvm_get_function(mod, "main");
    void* fptr = llvm_get_function_ptr(main_func);
    int (*app_main)() = (int(*)())fptr;
    int result = app_main();

    terminal_writestring("App returned: ");
    terminal_putchar('0' + result);
}
```

**Tasks**:
- [ ] Extend bootloader for 545MB loading
- [ ] Embed IR in kernel binary
- [ ] Initialize LLVM at boot
- [ ] Run simple IR function
- [ ] Verify Interpreter execution

---

### Phase 4.4: Profiling & JIT (Week 5-6)

**Goal**: Profile all calls, JIT compile hot functions

**Profiling Strategy**:
```c
struct function_profile {
    char name[64];
    uint64_t call_count;
    uint64_t total_cycles;
    uint64_t min_cycles;
    uint64_t max_cycles;
    int current_opt_level;  // 0=Interpreter, 1=O0, 2=O1, 3=O2, 4=O3
};

// Wrap every function call
void* execute_function(llvm_module_t* mod, const char* name, void* args) {
    uint64_t start = rdtsc();

    // Lookup or compile
    llvm_function_t* func = profile_get_or_compile(mod, name);

    // Execute
    void* result = call_function(func, args);

    // Record
    uint64_t cycles = rdtsc() - start;
    profile_record(name, cycles);

    // Check for recompilation
    if (should_recompile(name)) {
        int new_opt = get_next_opt_level(name);
        llvm_recompile(mod, name, new_opt);
    }

    return result;
}
```

**Recompilation Thresholds**:
```
Interpreter  ‚Üí  O0:   10 calls
O0           ‚Üí  O1:   100 calls
O1           ‚Üí  O2:   1000 calls
O2           ‚Üí  O3:   10000 calls
```

**Tasks**:
- [ ] Implement call profiling with rdtsc
- [ ] Track per-function statistics
- [ ] Implement tiered recompilation
- [ ] Measure speedup at each tier
- [ ] Target 100√ó speedup (Interpreter ‚Üí O3)

---

### Phase 4.5: Persistence (Week 7-8)

**Goal**: Save optimized code to disk, load on next boot

**Snapshot Format**:
```c
#define SNAP_MAGIC 0x504E4153  // "SNAP"

struct jit_snapshot {
    uint32_t magic;
    uint32_t version;
    uint32_t boot_count;
    uint32_t num_functions;

    struct {
        char name[64];
        uint32_t opt_level;
        uint32_t call_count;
        uint32_t code_size;
        uint32_t code_offset;  // From start of native_code[]
    } functions[256];

    uint8_t native_code[];  // Concatenated machine code
};
```

**FAT16 Integration**:
```
/boot/
  ‚îú‚îÄ‚îÄ kernel_base.img      # 545MB initial image
  ‚îî‚îÄ‚îÄ snapshots/
      ‚îú‚îÄ‚îÄ boot_001.snap    # After 10 boots (~545MB)
      ‚îú‚îÄ‚îÄ boot_010.snap    # After 100 boots (~200MB)
      ‚îú‚îÄ‚îÄ boot_100.snap    # After 500 boots (~30MB)
      ‚îî‚îÄ‚îÄ boot_500.snap    # After 1000+ boots (~5-10MB)
```

**Boot Sequence with Snapshots**:
```
1. Kernel boots, initializes LLVM
2. Check for latest snapshot
3. If snapshot exists:
   a. Load native code directly (skip Interpreter/JIT)
   b. Continue profiling for further optimization
4. If no snapshot:
   a. Execute all code with Interpreter
   b. Profile and JIT compile as needed
5. Every 10 boots: Save new snapshot
6. Snapshots converge toward pure native code
```

**Tasks**:
- [ ] Implement FAT16 write support
- [ ] Design snapshot serialization
- [ ] Save JIT code to disk
- [ ] Load snapshots at boot
- [ ] Verify convergence over 100+ boots

---

## üìä Success Metrics

### Boot 1 (Initial - Interpreter Only)
- Image size: ~545MB (FULL LLVM)
- Boot time: ~30-60s (load from disk)
- Execution: 100% Interpreter
- Performance: ~500√ó slower than AOT
- Memory: ~600MB (LLVM runtime + IR)

### Boot 100 (JIT Active)
- Image size: ~200MB (snapshot)
- Boot time: ~10-20s
- Execution: 80% JIT O1-O2, 20% Interpreter
- Performance: ~10√ó slower than AOT
- Memory: ~200MB (JIT code + runtime)

### Boot 500 (Converging)
- Image size: ~30MB (snapshot)
- Boot time: ~2-5s
- Execution: 95% JIT O3, 5% O2
- Performance: ~1.2√ó slower than AOT
- Memory: ~50MB (mostly native code)

### Boot 1000+ (Converged)
- Image size: ~5-10MB (pure native)
- Boot time: <1s
- Execution: 100% native (no LLVM!)
- Performance: Equal to AOT
- Memory: ~20MB (app only)

---

## üîß Technical Requirements

### C++ Runtime Minimal

```cpp
// kernel_lib/cxx_runtime.cpp
void* operator new(size_t size) {
    return malloc(size);
}

void operator delete(void* ptr) {
    free(ptr);
}

extern "C" void __cxa_pure_virtual() {
    panic("Pure virtual function called!");
}

extern "C" int __cxa_atexit(void (*)(void*), void*, void*) {
    return 0;  // No atexit in bare-metal
}

namespace std {
    void __throw_bad_alloc() {
        panic("Bad alloc!");
    }
}
```

### Custom Allocator

```c
// JIT allocator - executable memory pool
#define JIT_POOL_SIZE (128 * 1024 * 1024)  // 128MB
static uint8_t jit_pool[JIT_POOL_SIZE] __attribute__((aligned(4096)));
static size_t jit_offset = 0;

void* jit_alloc(size_t size) {
    if (jit_offset + size > JIT_POOL_SIZE) {
        panic("JIT pool exhausted!");
    }
    void* ptr = &jit_pool[jit_offset];
    jit_offset += (size + 4095) & ~4095;  // Align to 4KB
    return ptr;
}

void jit_reset() {
    jit_offset = 0;  // Reset for recompilation
}
```

---

## ‚ö†Ô∏è Risks & Mitigations

### Risk 1: Bootloader can't load 545MB
**Probability**: High
**Impact**: Blocking
**Mitigation**:
- Test with smaller LLVM first (e.g., link only Core+OrcJIT)
- Implement multi-stage loading if needed
- Consider loading LLVM from filesystem after boot

### Risk 2: 32-bit LLVM unavailable
**Probability**: Medium
**Impact**: High
**Mitigation**:
- Build LLVM from source with -m32
- All 213 libraries must be i686
- Test build process first

### Risk 3: C++ exceptions crash kernel
**Probability**: High
**Impact**: Medium
**Mitigation**:
- Compile with -fno-exceptions -fno-rtti
- Stub all exception handlers
- Test each LLVM API call for exceptions

### Risk 4: Memory exhaustion
**Probability**: Medium
**Impact**: Medium
**Mitigation**:
- Start with 1GB RAM in QEMU
- Implement memory monitoring
- JIT pool limited to 128MB

---

## üìö References

### Code Examples
- `tests/phase3/test_llvm_validation.cpp` - LLVM 18 OrcJIT usage
- `tests/phase3/test_tiered_jit.cpp` - Tiered compilation (userspace)
- `kernel_lib/` - Existing bare-metal runtime

### LLVM Documentation
- [LLVM OrcJIT Tutorial](https://llvm.org/docs/tutorial/BuildingAJIT1.html)
- [LLVM Passes](https://llvm.org/docs/Passes.html)
- [LLVM Optimization Levels](https://llvm.org/docs/OptBisect.html)

### Bare-Metal C++
- [OSDev C++](https://wiki.osdev.org/C++)
- [Freestanding C++](https://en.cppreference.com/w/cpp/freestanding)

---

## üöÄ Next Steps (Session 23)

### Immediate Actions
1. ‚úÖ LLVM 18 validated (545MB, 220 components)
2. ‚¨ú Build LLVM 18 as 32-bit static libraries
3. ‚¨ú Create minimal C++ runtime stubs
4. ‚¨ú Test linking kernel with LLVM
5. ‚¨ú Document any build issues

### Week 1 Goals
- LLVM 18 compiled for i686
- Static libraries ready for linking
- C++ runtime stubs working
- Simple test kernel boots with LLVM

**Ready to proceed!** üöÄ

---

**Created**: 2025-10-26
**Maintainer**: Claude Code Assistant
**Human**: @nickywan
**Status**: ‚úÖ Planning Complete - Ready for Implementation
