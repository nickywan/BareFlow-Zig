# ============================================================================
# FLUID KERNEL - MAKEFILE
# ============================================================================

# Tools
ASM = nasm
CC = clang-18
CXX = clang++-18
LD = ld
ASMFLAGS = -f bin

# Mode flags (default: automated profiling export)
# Set INTERACTIVE=1 for interactive mode with keyboard pauses
CFLAGS_CPU ?=
CXXFLAGS_CPU ?= $(CFLAGS_CPU)
CFLAGS_MODE =
ifdef INTERACTIVE
    CFLAGS_MODE = -DINTERACTIVE_MODE
endif
ifdef LIGHT
    CFLAGS_MODE += -DLIGHT_MODE
endif

# Paths
BOOT_DIR = boot
KERNEL_DIR = kernel
BUILD_DIR = build

# Optional CPU-specific flags (generated by tools/gen_cpu_profile.py)
CPU_FLAGS_FILE := $(KERNEL_DIR)/auto_cpu_flags.mk

# Auto-generate CPU flags if file doesn't exist
.PHONY: cpu-profile
cpu-profile:
	@echo "[1;33mGenerating CPU profile (QEMU-safe: i686)...[0m"
	@python3 tools/gen_cpu_profile.py --force-i686
	@echo "[0;32m✓ CPU profile generated: $(CPU_FLAGS_FILE)[0m"

# Generate on-demand if missing (direct invocation to avoid recursion)
$(CPU_FLAGS_FILE):
	@echo "[1;33mGenerating CPU profile (QEMU-safe: i686)...[0m"
	@python3 tools/gen_cpu_profile.py --force-i686
	@echo "[0;32m✓ CPU profile generated: $(CPU_FLAGS_FILE)[0m"

ifneq ("$(wildcard $(CPU_FLAGS_FILE))","")
include $(CPU_FLAGS_FILE)
endif

CFLAGS_COMMON = -I$(BUILD_DIR)

# Output
DISK_IMAGE = fluid.img
STAGE1_BIN = $(BUILD_DIR)/stage1.bin
STAGE2_BIN = $(BUILD_DIR)/stage2.bin
KERNEL_ELF = $(BUILD_DIR)/kernel.elf
KERNEL_BIN = $(BUILD_DIR)/kernel.bin
KERNEL_MAP = $(BUILD_DIR)/kernel.map

# Disk geometry
SECTOR_SIZE = 512
STAGE1_SECTORS = 1
STAGE2_SECTORS = 8
KERNEL_START_SECTOR = 9

CACHE_PROFILE_TAG ?= $(CPU_PROFILE_TAG)
CACHE_DIR := cache/$(CACHE_PROFILE_TAG)
# Temporarily disable cache embedding to test micro-JIT integration
CACHE_MODS :=
CACHE_NAMES :=
CACHE_EMBED_CS :=
CACHE_EMBED_OBJS :=
CACHE_REGISTRY :=
CACHE_REGISTRY_OBJ :=
CACHE_OBJECTS :=

# ifneq ($(CACHE_MODS),)
# CACHE_OBJECTS := $(CACHE_EMBED_OBJS) $(CACHE_REGISTRY_OBJ)

$(BUILD_DIR)/cache_embed_%.c: $(CACHE_DIR)/%.mod tools/embed_module.py | $(BUILD_DIR)
	python3 tools/embed_module.py --input $< --output $@ --name $*

$(BUILD_DIR)/cache_embed_%.o: $(BUILD_DIR)/cache_embed_%.c | $(BUILD_DIR)
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) -I$(KERNEL_DIR) \
		-c $< -o $@

$(CACHE_REGISTRY): $(CACHE_EMBED_CS) tools/gen_cache_registry.py | $(BUILD_DIR)
	python3 tools/gen_cache_registry.py --output $@ --modules $(CACHE_NAMES)

$(CACHE_REGISTRY_OBJ): $(CACHE_REGISTRY) | $(BUILD_DIR)
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) -I$(KERNEL_DIR) \
		-c $< -o $@

# endif

# Colors for output
RED = \033[0;31m
GREEN = \033[0;32m
YELLOW = \033[1;33m
NC = \033[0m # No Color

.PHONY: all clean run debug rebuild info

all: info $(DISK_IMAGE)
	@echo "$(GREEN)✓ Build complete!$(NC)"

# Create build directory

$(BUILD_DIR):
	@mkdir -p $(BUILD_DIR)

# Build Stage 1 (512 bytes)
$(STAGE1_BIN): $(BOOT_DIR)/stage1.asm | $(BUILD_DIR)
	@echo "$(YELLOW)Building Stage 1...$(NC)"
	$(ASM) $(ASMFLAGS) $< -o $@
	@SIZE=$$(stat -f%z "$@" 2>/dev/null || stat -c%s "$@" 2>/dev/null); \
	if [ $$SIZE -ne 512 ]; then \
		echo "$(RED)ERROR: Stage 1 must be exactly 512 bytes (got $$SIZE)$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)✓ Stage 1 built (512 bytes)$(NC)"

# Build Stage 2 (4KB = 8 sectors)
$(STAGE2_BIN): $(BOOT_DIR)/stage2.asm | $(BUILD_DIR)
	@echo "$(YELLOW)Building Stage 2...$(NC)"
	$(ASM) $(ASMFLAGS) $< -o $@
	@SIZE=$$(stat -f%z "$@" 2>/dev/null || stat -c%s "$@" 2>/dev/null); \
	EXPECTED=$$((512 * 8)); \
	if [ $$SIZE -ne $$EXPECTED ]; then \
		echo "$(RED)ERROR: Stage 2 must be exactly 4096 bytes (got $$SIZE)$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)✓ Stage 2 built (4096 bytes)$(NC)"

# Build Kernel (ASM entry + C code + stdlib + VGA + Module System + C++ Runtime + JIT Allocator + Profiling Export + FAT16 + Tests + Micro-JIT)
$(KERNEL_ELF): $(KERNEL_DIR)/entry.asm $(KERNEL_DIR)/kernel.c $(KERNEL_DIR)/stdlib.c $(KERNEL_DIR)/vga.c $(KERNEL_DIR)/module_loader.c $(KERNEL_DIR)/disk_module_loader.c $(KERNEL_DIR)/jit_allocator.c $(KERNEL_DIR)/jit_allocator_test.c $(KERNEL_DIR)/profiling_export.c $(KERNEL_DIR)/cache_loader.c $(KERNEL_DIR)/fat16.c $(KERNEL_DIR)/fat16_test.c $(KERNEL_DIR)/idt.c $(KERNEL_DIR)/idt_stub.asm $(KERNEL_DIR)/micro_jit.c $(KERNEL_DIR)/cxx_runtime.cpp $(KERNEL_DIR)/cxx_test.cpp $(KERNEL_DIR)/linker.ld $(CACHE_OBJECTS) | $(BUILD_DIR)
	@echo "$(YELLOW)Building Kernel with Module System and C++ Runtime...$(NC)"
	# Assemble entry point
	$(ASM) -f elf32 $(KERNEL_DIR)/entry.asm -o $(BUILD_DIR)/entry.o

	# Compile VGA driver
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/vga.c -o $(BUILD_DIR)/vga.o

	# Compile module loader
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/module_loader.c -o $(BUILD_DIR)/module_loader.o

	# Compile kernel C code
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/kernel.c -o $(BUILD_DIR)/kernel.o

	# Compile stdlib
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/stdlib.c -o $(BUILD_DIR)/stdlib.o

	# Compile JIT allocator
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/jit_allocator.c -o $(BUILD_DIR)/jit_allocator.o

	# Compile JIT allocator tests
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/jit_allocator_test.c -o $(BUILD_DIR)/jit_allocator_test.o

	# Compile profiling export system
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/profiling_export.c -o $(BUILD_DIR)/profiling_export.o

	# Compile cache loader
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/cache_loader.c -o $(BUILD_DIR)/cache_loader.o

	# Compile IDT setup
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/idt.c -o $(BUILD_DIR)/idt.o

	# Compile PIC driver
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/pic.c -o $(BUILD_DIR)/pic.o

	# Compile FAT16 filesystem driver
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/fat16.c -o $(BUILD_DIR)/fat16.o

	# Compile FAT16 test
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/fat16_test.c -o $(BUILD_DIR)/fat16_test.o

	# Compile disk module loader
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/disk_module_loader.c -o $(BUILD_DIR)/disk_module_loader.o

	# Compile Micro-JIT
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/micro_jit.c -o $(BUILD_DIR)/micro_jit.o

	# Compile function profiler
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/function_profiler.c -o $(BUILD_DIR)/function_profiler.o

	# Compile adaptive JIT
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/adaptive_jit.c -o $(BUILD_DIR)/adaptive_jit.o

	# Compile JIT demo
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/jit_demo.c -o $(BUILD_DIR)/jit_demo.o

	# Compile ELF loader
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/elf_loader.c -o $(BUILD_DIR)/elf_loader.o

	# Build test ELF module
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -c test/elf_test_module.c -o test/elf_test_module.o
	$(LD) -m elf_i386 -e test_function test/elf_test_module.o -o test/elf_test_module.elf

	# Embed test ELF as binary blob
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/elf_test_module_embed.o test/elf_test_module.elf

	# Compile ELF test
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/elf_test.c -o $(BUILD_DIR)/elf_test.o

	# Compile LLVM module manager
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/llvm_module_manager.c -o $(BUILD_DIR)/llvm_module_manager.o

	# Compile LLVM test
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/llvm_test.c -o $(BUILD_DIR)/llvm_test.o

	# Compile LLVM PGO test suite
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/llvm_test_pgo.c -o $(BUILD_DIR)/llvm_test_pgo.o

	# Compile LLVM PGO extended test suite
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/llvm_test_pgo_extended.c -o $(BUILD_DIR)/llvm_test_pgo_extended.o

	# Embed LLVM-compiled fibonacci modules
	@mkdir -p llvm_modules
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/fibonacci_O0_embed.o llvm_modules/fibonacci_O0.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/fibonacci_O1_embed.o llvm_modules/fibonacci_O1.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/fibonacci_O2_embed.o llvm_modules/fibonacci_O2.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/fibonacci_O3_embed.o llvm_modules/fibonacci_O3.elf

	# Embed LLVM-compiled matrix_mul modules
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/matrix_mul_O0_embed.o llvm_modules/matrix_mul_O0.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/matrix_mul_O1_embed.o llvm_modules/matrix_mul_O1.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/matrix_mul_O2_embed.o llvm_modules/matrix_mul_O2.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/matrix_mul_O3_embed.o llvm_modules/matrix_mul_O3.elf

	# Embed LLVM-compiled sha256 modules
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/sha256_O0_embed.o llvm_modules/sha256_O0.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/sha256_O1_embed.o llvm_modules/sha256_O1.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/sha256_O2_embed.o llvm_modules/sha256_O2.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/sha256_O3_embed.o llvm_modules/sha256_O3.elf

	# Embed LLVM-compiled primes modules
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/primes_O0_embed.o llvm_modules/primes_O0.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/primes_O1_embed.o llvm_modules/primes_O1.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/primes_O2_embed.o llvm_modules/primes_O2.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/primes_O3_embed.o llvm_modules/primes_O3.elf

	# Embed LLVM-compiled fft_1d modules
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/fft_1d_O0_embed.o llvm_modules/fft_1d_O0.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/fft_1d_O1_embed.o llvm_modules/fft_1d_O1.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/fft_1d_O2_embed.o llvm_modules/fft_1d_O2.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/fft_1d_O3_embed.o llvm_modules/fft_1d_O3.elf

	# Embed LLVM-compiled quicksort modules
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/quicksort_O0_embed.o llvm_modules/quicksort_O0.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/quicksort_O1_embed.o llvm_modules/quicksort_O1.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/quicksort_O2_embed.o llvm_modules/quicksort_O2.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/quicksort_O3_embed.o llvm_modules/quicksort_O3.elf

	# Embed LLVM-compiled compute_dispatch modules
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/compute_dispatch_O0_embed.o llvm_modules/compute_dispatch_O0.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/compute_dispatch_O1_embed.o llvm_modules/compute_dispatch_O1.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/compute_dispatch_O2_embed.o llvm_modules/compute_dispatch_O2.elf
	$(LD) -m elf_i386 -r -b binary -o $(BUILD_DIR)/compute_dispatch_O3_embed.o llvm_modules/compute_dispatch_O3.elf

	# Compile bitcode module loader
	$(CC) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CFLAGS_CPU) $(CFLAGS_COMMON) \
		-c $(KERNEL_DIR)/bitcode_module.c -o $(BUILD_DIR)/bitcode_module.o

	$(ASM) -f elf32 $(KERNEL_DIR)/idt_stub.asm -o $(BUILD_DIR)/idt_stub.o

	# Compile C++ runtime
	$(CXX) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CXXFLAGS_CPU) $(CFLAGS_COMMON) \
		-fno-exceptions -fno-rtti -fno-threadsafe-statics \
		-c $(KERNEL_DIR)/cxx_runtime.cpp -o $(BUILD_DIR)/cxx_runtime.o

	# Compile C++ tests
	$(CXX) -m32 -ffreestanding -nostdlib -fno-pie -O2 -Wall -Wextra $(CFLAGS_MODE) $(CXXFLAGS_CPU) $(CFLAGS_COMMON) \
		-fno-exceptions -fno-rtti -fno-threadsafe-statics \
		-c $(KERNEL_DIR)/cxx_test.cpp -o $(BUILD_DIR)/cxx_test.o

	# Build llvm-libc first
	@$(MAKE) -f Makefile.llvmlibc all -s

	# Link everything (ORDRE IMPORTANT - libllvmlibc.a LAST for symbol resolution)
	$(LD) -m elf_i386 -T $(KERNEL_DIR)/linker.ld -Map $(KERNEL_MAP) \
		$(BUILD_DIR)/entry.o $(BUILD_DIR)/kernel.o $(BUILD_DIR)/module_loader.o \
		$(BUILD_DIR)/disk_module_loader.o \
		$(BUILD_DIR)/vga.o $(BUILD_DIR)/stdlib.o $(BUILD_DIR)/jit_allocator.o \
		$(BUILD_DIR)/jit_allocator_test.o $(BUILD_DIR)/profiling_export.o \
		$(BUILD_DIR)/cache_loader.o $(BUILD_DIR)/fat16.o $(BUILD_DIR)/fat16_test.o $(BUILD_DIR)/idt.o $(BUILD_DIR)/idt_stub.o \
		$(BUILD_DIR)/pic.o $(BUILD_DIR)/micro_jit.o $(BUILD_DIR)/function_profiler.o $(BUILD_DIR)/adaptive_jit.o \
		$(BUILD_DIR)/jit_demo.o $(BUILD_DIR)/elf_loader.o $(BUILD_DIR)/elf_test.o $(BUILD_DIR)/elf_test_module_embed.o \
		$(BUILD_DIR)/llvm_module_manager.o $(BUILD_DIR)/llvm_test.o $(BUILD_DIR)/llvm_test_pgo.o $(BUILD_DIR)/llvm_test_pgo_extended.o \
		$(BUILD_DIR)/fibonacci_O0_embed.o $(BUILD_DIR)/fibonacci_O1_embed.o \
		$(BUILD_DIR)/fibonacci_O2_embed.o $(BUILD_DIR)/fibonacci_O3_embed.o \
		$(BUILD_DIR)/matrix_mul_O0_embed.o $(BUILD_DIR)/matrix_mul_O1_embed.o \
		$(BUILD_DIR)/matrix_mul_O2_embed.o $(BUILD_DIR)/matrix_mul_O3_embed.o \
		$(BUILD_DIR)/sha256_O0_embed.o $(BUILD_DIR)/sha256_O1_embed.o \
		$(BUILD_DIR)/sha256_O2_embed.o $(BUILD_DIR)/sha256_O3_embed.o \
		$(BUILD_DIR)/primes_O0_embed.o $(BUILD_DIR)/primes_O1_embed.o \
		$(BUILD_DIR)/primes_O2_embed.o $(BUILD_DIR)/primes_O3_embed.o \
		$(BUILD_DIR)/fft_1d_O0_embed.o $(BUILD_DIR)/fft_1d_O1_embed.o \
		$(BUILD_DIR)/fft_1d_O2_embed.o $(BUILD_DIR)/fft_1d_O3_embed.o \
		$(BUILD_DIR)/quicksort_O0_embed.o $(BUILD_DIR)/quicksort_O1_embed.o \
		$(BUILD_DIR)/quicksort_O2_embed.o $(BUILD_DIR)/quicksort_O3_embed.o \
		$(BUILD_DIR)/compute_dispatch_O0_embed.o $(BUILD_DIR)/compute_dispatch_O1_embed.o \
		$(BUILD_DIR)/compute_dispatch_O2_embed.o $(BUILD_DIR)/compute_dispatch_O3_embed.o \
		$(BUILD_DIR)/bitcode_module.o \
		$(CACHE_OBJECTS) $(BUILD_DIR)/cxx_runtime.o $(BUILD_DIR)/cxx_test.o \
		build/llvmlibc/libllvmlibc.a -o $(KERNEL_ELF)
	@SIZE=$$(stat -f%z "$(KERNEL_ELF)" 2>/dev/null || stat -c%s "$(KERNEL_ELF)" 2>/dev/null); \
	echo "$(GREEN)✓ Kernel ELF built ($$SIZE bytes)$(NC)"

$(KERNEL_BIN): $(KERNEL_ELF)
	@echo "$(YELLOW)Generating flat kernel binary...$(NC)"
	objcopy -O binary $(KERNEL_ELF) $(KERNEL_BIN)
	@SIZE=$$(stat -f%z "$(KERNEL_BIN)" 2>/dev/null || stat -c%s "$(KERNEL_BIN)" 2>/dev/null); \
	echo "$(GREEN)✓ Kernel BIN built ($$SIZE bytes)$(NC)"
	@echo "$(YELLOW)Verifying signature...$(NC)"
	@SIG=$$(hexdump -n 4 -e '4/1 "%02x"' $(KERNEL_BIN)); \
	if [ "$$SIG" = "44554c46" ]; then \
		echo "$(GREEN)✓ Signature OK: FLUD (44554c46)$(NC)"; \
	else \
		echo "$(RED)✗ Invalid signature: 0x$$SIG$(NC)"; \
		exit 1; \
	fi

# Create bootable disk image
$(DISK_IMAGE): $(STAGE1_BIN) $(STAGE2_BIN) $(KERNEL_BIN)
	@echo "$(YELLOW)Creating disk image...$(NC)"
	# Create empty 1.44MB floppy image
	dd if=/dev/zero of=$@ bs=512 count=2880 status=none
	
	# Write Stage 1 at sector 0 (boot sector)
	dd if=$(STAGE1_BIN) of=$@ bs=512 count=1 seek=0 conv=notrunc status=none
	
	# Write Stage 2 at sector 1 (right after boot sector)
	dd if=$(STAGE2_BIN) of=$@ bs=512 count=8 seek=1 conv=notrunc status=none
	
	# Write Kernel at sector 9 (after stage1 + stage2)
	dd if=$(KERNEL_BIN) of=$@ bs=512 seek=$(KERNEL_START_SECTOR) conv=notrunc status=none
	
	@echo "$(GREEN)✓ Disk image created: $(DISK_IMAGE)$(NC)"

# Show disk layout
info:
	@echo "$(YELLOW)=== Fluid Bootloader Disk Layout ===$(NC)"
	@echo "Sector 0:       Stage 1 (bootloader)"
	@echo "Sectors 1-8:    Stage 2 (extended bootloader)"
	@echo "Sectors 9+:     Kernel"
	@echo ""

# Run in QEMU
run: $(DISK_IMAGE)
	@echo "$(GREEN)Starting QEMU...$(NC)"
	qemu-system-i386 -drive file=$(DISK_IMAGE),format=raw -serial stdio

# Debug with QEMU
debug: $(DISK_IMAGE)
	@echo "$(GREEN)Starting QEMU in debug mode...$(NC)"
	qemu-system-i386 -drive file=$(DISK_IMAGE),format=raw -serial stdio -d int,cpu_reset -no-reboot

# Clean build files
clean:
	@echo "$(RED)Cleaning build files...$(NC)"
	rm -rf $(BUILD_DIR)
	rm -f $(DISK_IMAGE)
	@$(MAKE) -f Makefile.llvmlibc clean -s
	@echo "$(GREEN)✓ Clean complete$(NC)"

# Rebuild from scratch
rebuild: clean all

# Help
help:
	@echo "Fluid Kernel Build System"
	@echo ""
	@echo "Targets:"
	@echo "  all     - Build everything (default)"
	@echo "  run     - Build and run in QEMU"
	@echo "  debug   - Build and run with debug output"
	@echo "  clean   - Remove all build files"
	@echo "  rebuild - Clean and build"
	@echo "  info    - Show disk layout"
	@echo "  help    - Show this help"
	@echo ""
	@echo "Build Modes:"
	@echo "  make              - Automated mode (default, no keyboard pauses)"
	@echo "  make INTERACTIVE=1 - Interactive mode (with keyboard pauses)"
	@echo ""
	@echo "Examples:"
	@echo "  make clean && make                  # Automated profiling export"
	@echo "  make clean && make INTERACTIVE=1    # Interactive testing"
	@echo "  make run INTERACTIVE=1              # Run with keyboard pauses"
.PHONY: modules
modules:
	@echo "[1;33mCompiling modules...[0m"
	@$(MAKE) -f Makefile.modules all
	@echo "[0;32m✓ Modules compiled[0m"

.PHONY: pgo-profile
pgo-profile:
	@echo "[1;33m=== PGO Profiling Workflow ===[0m"
	@echo "1. Building kernel..."
	@$(MAKE) -s
	@echo "2. Running kernel and capturing profiling data..."
	@timeout 10 qemu-system-i386 -drive file=$(DISK_IMAGE),format=raw \
		-serial file:build/profiling_export.json -display none 2>&1 || true
	@echo "3. Extracting JSON..."
	@grep -A 1000 "BEGIN JSON" build/profiling_export.json | \
		grep -B 1000 "END JSON" | sed "1d;\$$d" > build/profile.json || true
	@echo "[0;32m✓ Profile captured: build/profile.json[0m"

.PHONY: pgo-analyze
pgo-analyze: pgo-profile
	@echo "[1;33m=== PGO Analysis ===[0m"
	@python3 tools/pgo_recompile.py build/profile.json --plan-out build/pgo_plan.json
	@echo "[0;32m✓ PGO plan: build/pgo_plan.json[0m"

.PHONY: pgo-apply
pgo-apply: pgo-analyze
	@echo "[1;33m=== Applying PGO Optimizations ===[0m"
	@python3 tools/pgo_recompile.py build/profile.json --apply \
		--module-dir modules --output-dir cache
	@echo "[0;32m✓ Optimized modules in cache/[0m"
	@echo "[1;33mℹ️  Next: Integrate optimized modules into kernel build[0m"
