# Issues Resolved - Base de Donn√©es des Probl√®mes

**Objectif**: Documenter tous les probl√®mes rencontr√©s et leurs solutions pour √©viter de r√©p√©ter les m√™mes erreurs.

**Utilisation**: Consulter ce document AVANT d'impl√©menter de nouvelles fonctionnalit√©s ou lors du debugging.

---

## Table des Mati√®res

1. [Boot Issues](#boot-issues)
2. [Compilation Issues](#compilation-issues)
3. [Runtime Issues](#runtime-issues)
4. [Linker Issues](#linker-issues)
5. [QEMU/Testing Issues](#qemutesting-issues)

---

## Boot Issues

### üî¥ CRITIQUE #1: Kernel ne boot pas - CPU reset imm√©diat

**Session**: 46, 47
**Sympt√¥mes**:
- QEMU affiche "Booting from CD-ROM" puis reset imm√©diat
- Aucune sortie s√©rie
- CPU triple fault ou exception non g√©r√©e

**Causes Possibles**:

#### 1.1 Multiboot2 Header Invalide
**Probl√®me**: GRUB ne reconna√Æt pas le kernel comme bootable
**Solution**:
```assembly
# boot64.S - Section .multiboot
.section .multiboot
.align 8
multiboot_header_start:
    .long 0xE85250D6                    # Magic number (Multiboot2)
    .long 0                             # Architecture: i386 (protected mode)
    .long multiboot_header_end - multiboot_header_start
    .long -(0xE85250D6 + 0 + (multiboot_header_end - multiboot_header_start))
```

**Validation**:
```bash
grub-file --is-x86-multiboot2 iso/boot/kernel
echo $?  # Doit retourner 0
```

#### 1.2 BSS Non-Zeroed (Pages Tables Corrompues)
**Probl√®me**: Page tables dans .bss contiennent des donn√©es al√©atoires
**Sympt√¥me**: Triple fault lors de l'activation de la pagination
**Solution**: Zeroer le BSS AVANT d'activer la pagination

```assembly
# boot64.S - AVANT cr0/cr3 setup
# Zero BSS section
mov $__bss_start, %rdi
mov $__bss_end, %rcx
sub %rdi, %rcx
xor %rax, %rax
rep stosb
```

**R√©f√©rence**: Session 46, commit 1d01b7c

#### 1.3 Mismatch 32-bit Boot / 64-bit Kernel
**Probl√®me**: boot.S (32-bit) essaie de charger kernel 64-bit
**Sympt√¥me**: Kernel ne d√©marre jamais apr√®s "Booting from CD-ROM"
**Solution**: Utiliser boot64.S (native 64-bit) avec GRUB Multiboot2

**Avant (CASS√â)**:
```assembly
# boot.S - 32-bit bootloader
.code32
# ... setup page tables
# ... passage en long mode
jmp kernel_main  # ‚ùå Kernel 64-bit, incompatible
```

**Apr√®s (FONCTIONNE)**:
```assembly
# boot64.S - Native 64-bit
.code64
kernel_entry:
    # GRUB nous met d√©j√† en 64-bit!
    mov $stack_top, %rsp
    call kernel_main  # ‚úÖ Compatible
```

**R√©f√©rence**: Session 47, commit f34f03d - BREAKTHROUGH

#### 1.4 Stack Overflow / Red Zone Corruption
**Probl√®me**: Stack corrompu par interruptions
**Sympt√¥me**: Crash al√©atoire, donn√©es corrompues
**Solution**: D√©sactiver red zone + stack 8MB

```bash
# Compilation flags
-mno-red-zone      # CRITIQUE pour kernel 64-bit
-mcmodel=kernel    # Adressage 64-bit
```

```zig
// build.zig
kernel.root_module.red_zone = false;
```

**R√©f√©rence**: Session 46, 47

---

## Compilation Issues

### üî¥ CRITIQUE #2: Zig g√©n√®re des adresses 32-bit au lieu de 64-bit

**Session**: 47 Part 2
**Sympt√¥mes**:
- Infinite 'E' characters sur sortie s√©rie
- Garbage data au lieu des strings attendus
- Kernel semble "boucler" sans raison

**Diagnostic**:
```bash
objdump -d iso/boot/kernel | grep -A5 kernel_main
```

**Probl√®me Identifi√©**:
```assembly
# ‚ùå CASS√â - Zig g√©n√®re EDI (32-bit)
mov $0x101011,%edi    # Charge adresse dans registre 32-bit
call serial_print     # Pointeur invalide!

# ‚úÖ CORRECT - Devrait √™tre RDI (64-bit)
mov $0x101011,%rdi    # Charge adresse dans registre 64-bit
```

**Cause**: Flag `-mcmodel=kernel` seulement sur boot64.S, pas sur code Zig

**Solution**:
```bash
# Compilation manuelle avec code model kernel
zig build-obj -target x86_64-freestanding -mcmodel=kernel \
    -O ReleaseSafe src/main_simple.zig -femit-bin=main_simple.o
```

**Bonus**: Avec `-mcmodel=kernel`, Zig inline compl√®tement `serial_print()`:
```assembly
# Plus de pointeurs du tout! Sortie directe des caract√®res
mov $0x42,%al   # 'B'
out %al,(%dx)
mov $0x61,%al   # 'a'
out %al,(%dx)
```

**R√©f√©rence**: Session 47, commit 3d87c24, `SESSION_47_STRING_POINTER_FIX.md`

### üü° #3: Property 'code_model' n'existe pas dans Zig 0.13

**Session**: 47
**Sympt√¥me**: Build hang ou erreur de propri√©t√© inconnue
**Solution**: Utiliser compilation manuelle, pas build.zig

```zig
// ‚ùå NE FONCTIONNE PAS (Zig 0.13)
kernel.root_module.code_model = .kernel;

// ‚úÖ WORKAROUND - Documenter dans build.zig
// NOTE (Session 47): kernel.root_module.code_model property does not exist in Zig 0.13
// Manual compilation required:
//   zig build-obj -mcmodel=kernel src/main_simple.zig
```

**R√©f√©rence**: build.zig lignes 38-43

### üü° #4: Cannot use addCSourceFile for .zig files

**Session**: 47
**Sympt√¥me**: Flags pas appliqu√©s aux fichiers Zig
**Solution**: `addCSourceFile()` est pour C uniquement, pas Zig

```zig
// ‚ùå NE FONCTIONNE PAS
kernel.root_module.addCSourceFile(.{
    .file = b.path("src/main_simple.zig"),  // Zig file!
    .flags = &.{"-mcmodel=kernel"},
});

// ‚úÖ CORRECT - Compilation manuelle
// Voir build_simple.sh
```

---

## Runtime Issues

### üî¥ CRITIQUE #5: Serial I/O - Infinite 'E' characters

**Session**: 47
**Sympt√¥mes**:
- Single character works: `serial_write('A')` ‚úÖ
- Single string works: `serial_print("ABC\n")` ‚úÖ
- Multiple strings fail: Infinite 'E' or garbage ‚ùå

**Cause**: Voir [Issue #2](#üî¥-critique-2-zig-g√©n√®re-des-adresses-32-bit-au-lieu-de-64-bit) - Adressage 32-bit

**User Insight**: *"il ne pointe pas vers la bonne adresse et donc ne rencontre jamais le \0"*

**Solution**: Compiler avec `-mcmodel=kernel`

**Validation**:
```bash
timeout 3 qemu-system-x86_64 -M q35 -m 128 -cdrom bareflow-simple.iso \
    -serial file:serial-test.log
cat serial-test.log
# Doit afficher exactement 51 bytes:
# BareFlow Zig Kernel\n
# Serial I/O Test\n
# Boot complete!\n
```

### üü° #6: Serial Polling Too Strict

**Session**: 47
**Sympt√¥me**: Serial output parfois manquant
**Probl√®me**: Polling THRE + TEMT (mask 0x60) trop strict

```zig
// ‚ùå Trop strict
while ((inb(COM1 + 5) & 0x60) != 0x60) {}

// ‚úÖ Standard UART - THRE seulement
while ((inb(COM1 + 5) & 0x20) == 0) {}
```

**Note**: Ce n'√©tait PAS la cause du bug de pointeurs, mais c'est la bonne pratique.

### üü° #7: VGA Buffer Addressing

**Session**: 47
**Sympt√¥me**: VGA output ne s'affiche pas
**Solution**: VGA buffer √† 0xB8000 (identity mapped ou higher-half)

```zig
const VGA_BUFFER = 0xB8000;  // Physical address
// OU
const VGA_BUFFER = 0xFFFFFFFF800B8000;  // Higher-half
```

### üî¥ CRITIQUE #14: Hex Printing Corruption - Conditional Toujours True

**Session**: 47 (Continuation)
**Sympt√¥mes**:
- Hex digits A-F affichent caract√®res incorrects ('<', '>', '?')
- Pattern: -7 offset ('C'‚Üí'<' = 0x43‚Üí0x3C)
- Test: `0x123456789ABCDEF0` ‚Üí `0x123456789A<=>?0`
- Analyse: `nibble=12` produit '0'+12 au lieu de 'A'+2

**Diagnostic**:
```bash
# Serial output montre corruption
Test hex: 0x123456789A<=>?0  # ‚ùå CASS√â
Test hex: 0x123456789ABCDEF0 # ‚úÖ CORRECT apr√®s fix
```

**Cause Racine**: Zig ReleaseFast optimizer CASSE les expressions conditionnelles
```zig
// ‚ùå CASS√â - Conditional TOUJOURS true en ReleaseFast
fn nibble_to_hex(nibble: u8) u8 {
    return if (nibble < 10) '0' + nibble else 'A' + (nibble - 10);
}

// ‚ùå TOUJOURS CASS√â - M√™me avec if/else explicite!
fn nibble_to_hex(nibble: u8) u8 {
    if (nibble < 10) {
        return '0' + nibble;
    } else {
        return 'A' + (nibble - 10);
    }
}
// La comparaison (nibble < 10) retourne TOUJOURS true!
```

**Insight Utilisateur**: *"en fait le hex printing peut cacher un probl√®me sous jacent qui risque de nous peter √† la figure, n'est pas un probl√®me de return value ?"*

**Solution**: Lookup table (√©vite le conditional compl√®tement)
```zig
// ‚úÖ FONCTIONNE - Compile-time constant lookup table
const HEX_DIGITS: [16]u8 = [_]u8{
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

fn nibble_to_hex(nibble: u8) u8 {
    return HEX_DIGITS[nibble & 0xF];
}
```

**Pourquoi √ßa marche**:
- Pas de branches conditionnelles ‚Üí Pas de bug d'optimisation
- Array indexing direct avec bounds check (& 0xF)
- Const array plac√©e en .rodata section
- √âvite les probl√®mes d'adressage 32-bit

**Validation**:
```
Test hex: 0x123456789ABCDEF0 ‚úì
Result 1: 0x0000008E (expected 0x8E = 142) ‚úì
Result 2: 0xFFFFFFF8 (expected -8) ‚úì
Result 3: 0x00000412 (expected 0x412 = 1042) ‚úì
```

**Impact**: Ce bug cachait √©galement le probl√®me #15 (32MB heap)

**R√©f√©rence**: Session 47 (Continuation), commit 747f84e, `SESSION_47_ALLOCATOR_FIXES.md`

### üî¥ CRITIQUE #15: 32MB Heap Triple Fault

**Session**: 47 (Continuation)
**Sympt√¥mes**:
- Kernel fonctionne avec 1MB heap ‚úÖ
- Kernel reboot 3√ó (triple fault) avec 32MB heap ‚ùå
- Serial log: "Allocated array - OK" puis CPU reset

**Configuration Test√©e**:
```zig
// ‚ùå TRIPLE FAULT
var heap_buffer: [32 * 1024 * 1024]u8 align(4096) = undefined;

// ‚úÖ FONCTIONNE (mais insuffisant)
var heap_buffer: [1 * 1024 * 1024]u8 align(4096) = undefined;
```

**Hypoth√®se Initiale**: BSS zeroing timeout
```assembly
# boot64.S - Zeroing 32MB byte-par-byte
rep stosb  # TR√àS lent pour 32MB (33,554,432 iterations!)
```

**Resolution INATTENDUE**: Le fix du probl√®me #14 (lookup table) a √©galement r√©solu ce probl√®me!

**Apr√®s Fix #14**:
```zig
var heap_buffer: [32 * 1024 * 1024]u8 align(4096) = undefined;  // ‚úÖ FONCTIONNE!
```

**Validation**:
```
Heap Configuration:
  Buffer size: 32 MB (testing) ‚úì

=== Testing Simple Allocator (32MB heap!) ===
About to allocate TestStruct...
simple_alloc returned
Casts completed
Set magic
Set value
Allocated TestStruct - OK ‚úì
Magic value - OK ‚úì
Allocated array - OK ‚úì
...
Kernel ready. Halting. ‚úì
```

**Explication Probable**:
1. **Code corrompu**: Conditional cass√© g√©n√©rait code corrompu affectant m√©moire
2. **Timing diff√©rent**: Lookup table change timing, permettant BSS zeroing de finir
3. **Moins de heap pressure**: Pas de code conditionnel allou√© sur heap
4. **Const en .rodata**: R√©duit taille BSS √† zeroer

**Requ√™te Utilisateur**: *"continue a investiguer aussi sur la hea de 32m"* ‚Üí Investigation compl√®te, probl√®me R√âSOLU!

**Note Importante**: Les deux bugs (#14 et #15) √©taient **LI√âS** - fix de l'un a r√©solu l'autre.

**R√©f√©rence**: Session 47 (Continuation), commit 747f84e, `SESSION_47_ALLOCATOR_FIXES.md`

---

## Linker Issues

### üü° #8: Section Alignment Syntax Error

**Session**: 46
**Sympt√¥me**: `ld.lld-18: error: malformed number: ALIGN`
**Solution**: Utiliser syntaxe correcte pour ALIGN()

```ld
/* ‚ùå CASS√â */
.bss ALIGN(4096) : {

/* ‚úÖ CORRECT */
.bss : ALIGN(4096) {
```

**R√©f√©rence**: src/linker.ld

### üü° #9: BSS Boundaries Not Defined

**Session**: 46
**Sympt√¥me**: BSS zeroing √©choue silencieusement
**Solution**: D√©finir __bss_start et __bss_end dans linker script

```ld
.bss : ALIGN(4096) {
    __bss_start = .;
    *(.bss)
    *(.bss.*)
    *(COMMON)
    __bss_end = .;
}
```

Usage dans boot64.S:
```assembly
mov $__bss_start, %rdi
mov $__bss_end, %rcx
sub %rdi, %rcx
xor %rax, %rax
rep stosb
```

### üî¥ CRITIQUE #10: PIE (Position Independent Executable) Enabled

**Session**: 46, 47
**Sympt√¥me**: Relocations dans le binaire, GRUB rejette
**Solution**: D√©sactiver PIE explicitement

```zig
// build.zig
kernel.pie = false;
```

```bash
# Compilation manuelle
gcc -fno-pie ...
ld.lld-18 -no-pie ...
```

**Validation**:
```bash
readelf -h iso/boot/kernel | grep Type
# Doit afficher: Type: EXEC (Executable file)
# PAS: Type: DYN (Shared object file)
```

---

## QEMU/Testing Issues

### üü° #11: QEMU ne d√©marre pas avec -kernel

**Session**: 46, 47
**Sympt√¥me**: `qemu-system-x86_64 -kernel kernel` ‚Üí erreur ou hang
**Solution**: Utiliser ISO + GRUB, pas -kernel direct

```bash
# ‚ùå NE FONCTIONNE PAS (Multiboot2)
qemu-system-x86_64 -kernel iso/boot/kernel

# ‚úÖ FONCTIONNE - ISO bootable
grub-mkrescue -o bareflow.iso iso/
qemu-system-x86_64 -M q35 -m 128 -cdrom bareflow.iso -serial stdio
```

**Pourquoi**: QEMU `-kernel` supporte Multiboot1, pas Multiboot2

### üü° #12: Serial Output Non Visible

**Session**: 46, 47
**Sympt√¥me**: Kernel s'ex√©cute mais pas de sortie
**Solutions**:

```bash
# Option 1: Redirection vers fichier
qemu-system-x86_64 -serial file:serial.log -cdrom bareflow.iso

# Option 2: Sortie stdio (terminal)
qemu-system-x86_64 -serial stdio -cdrom bareflow.iso

# Option 3: Debugcon (early boot)
qemu-system-x86_64 -debugcon file:debug.log -cdrom bareflow.iso
```

**Usage debugcon dans boot64.S**:
```assembly
# Port 0xE9 - QEMU debugcon
mov $0xE9, %dx
mov $'B', %al    # Signal 'B' for "BSS zeroed"
out %al, (%dx)
```

### üü° #13: ISO Checksum Different

**Session**: 47
**Sympt√¥me**: ISO rebuilds avec checksums diff√©rents
**Cause**: Timestamps dans ISO filesystem
**Solution**: V√©rifier le KERNEL, pas l'ISO

```bash
# ‚ùå Ne compare pas les ISO
sha256sum bareflow.iso bareflow-new.iso

# ‚úÖ Compare les kernels
sudo mount bareflow.iso /mnt -o loop
sha256sum /mnt/boot/kernel
sudo umount /mnt
```

---

## Quick Reference - Commandes Essentielles

### Validation Pre-Boot
```bash
# 1. V√©rifier Multiboot2
grub-file --is-x86-multiboot2 iso/boot/kernel
echo $?  # Doit √™tre 0

# 2. V√©rifier type ELF
readelf -h iso/boot/kernel | grep Type
# Doit √™tre: EXEC (pas DYN)

# 3. V√©rifier sections
objdump -h iso/boot/kernel | grep -E "\.text|\.rodata|\.data|\.bss"

# 4. V√©rifier entry point
readelf -h iso/boot/kernel | grep Entry
```

### Debugging Serial I/O
```bash
# 1. Test avec serial output
timeout 3 qemu-system-x86_64 -M q35 -m 128 -cdrom kernel.iso \
    -serial file:serial.log
cat serial.log

# 2. V√©rifier byte count
wc -c serial.log
xxd serial.log | head -10

# 3. D√©sassembler kernel_main
objdump -d iso/boot/kernel | grep -A20 kernel_main
```

### Debugging Boot Sequence
```bash
# 1. Debugcon early boot
timeout 3 qemu-system-x86_64 -cdrom kernel.iso \
    -debugcon file:debug.log -no-reboot
cat debug.log

# 2. CPU debug logs
qemu-system-x86_64 -cdrom kernel.iso \
    -d cpu_reset,guest_errors -no-reboot

# 3. Interrupt debug
qemu-system-x86_64 -cdrom kernel.iso \
    -d int -no-reboot
```

---

## Workflow de Resolution

### √âtape 1: Identifier le Sympt√¥me
- [ ] Kernel ne boot pas ‚Üí [Boot Issues](#boot-issues)
- [ ] Kernel boot mais crash ‚Üí [Runtime Issues](#runtime-issues)
- [ ] Compilation √©choue ‚Üí [Compilation Issues](#compilation-issues)
- [ ] Linking √©choue ‚Üí [Linker Issues](#linker-issues)

### √âtape 2: Validation Syst√©matique
1. **Multiboot2**: `grub-file --is-x86-multiboot2`
2. **ELF Type**: `readelf -h | grep Type` ‚Üí EXEC
3. **Entry Point**: `readelf -h | grep Entry`
4. **BSS Zeroing**: V√©rifier code dans boot64.S
5. **Code Model**: `objdump -d | grep kernel_main` ‚Üí V√©rifier RDI (64-bit)

### √âtape 3: Debugging Progressif
1. **Boot**: Debugcon ‚Üí CPU logs ‚Üí Serial output
2. **Runtime**: Serial I/O ‚Üí VGA buffer ‚Üí GDB
3. **Compilation**: Disassembly ‚Üí Section dump ‚Üí Symbol table

### √âtape 4: Documentation
- [ ] Ajouter probl√®me √† ce document
- [ ] Cr√©er session document si investigation longue
- [ ] Commit avec message d√©taill√©
- [ ] Mettre √† jour CLAUDE.md si pattern r√©current

---

## Patterns R√©currents

### üîÅ Pattern #1: "Kernel boot mais pas de sortie"
**Checklist**:
1. Serial init appel√©? (`serial_init()` dans kernel_main)
2. QEMU avec `-serial stdio` ou `-serial file:log`?
3. COM1 port correct? (0x3F8)
4. Polling correct? (THRE bit 5, mask 0x20)

### üîÅ Pattern #2: "Compilation OK mais linking √©choue"
**Checklist**:
1. Linker script pr√©sent? (`-T src/linker.ld`)
2. Sections d√©finies? (.text, .rodata, .data, .bss)
3. Entry point d√©clar√©? (`ENTRY(kernel_entry)`)
4. BSS boundaries? (`__bss_start`, `__bss_end`)

### üîÅ Pattern #3: "GRUB ne reconna√Æt pas le kernel"
**Checklist**:
1. Multiboot2 header? (magic 0xE85250D6)
2. Architecture i386? (pas x86_64 pour Multiboot2!)
3. Checksum correct?
4. Section .multiboot en d√©but de fichier?

### üîÅ Pattern #4: "Pointeurs/adresses invalides"
**Checklist**:
1. Code model kernel? (`-mcmodel=kernel`)
2. Red zone d√©sactiv√©e? (`-mno-red-zone`)
3. PIE d√©sactiv√©? (`-fno-pie`, `kernel.pie = false`)
4. Registres 64-bit utilis√©s? (RDI, RSI, RDX - pas EDI, ESI, EDX)

---

## Lessons Learned - Best Practices

### ‚úÖ DO: Toujours Faire
1. **Compile avec `-mcmodel=kernel`** pour code 64-bit kernel
2. **D√©sactiver PIE** (`kernel.pie = false`)
3. **D√©sactiver red zone** (`-mno-red-zone`)
4. **Zeroer BSS** avant utilisation (page tables, stack, etc.)
5. **Valider Multiboot2** avec `grub-file`
6. **Tester dans QEMU** avant hardware
7. **V√©rifier disassembly** pour bugs de compilation
8. **Documenter IMM√âDIATEMENT** apr√®s r√©solution

### ‚ùå DON'T: Ne Jamais Faire
1. **Assumer que userspace = bare-metal** ‚Üí Toujours tester QEMU
2. **Utiliser `-kernel` avec Multiboot2** ‚Üí Utiliser ISO + GRUB
3. **Oublier BSS zeroing** ‚Üí Page tables corrompues
4. **Mixer 32-bit/64-bit** ‚Üí Utiliser architecture consistante
5. **Ignorer les warnings** ‚Üí Souvent signes de vrais probl√®mes
6. **Commit sans test** ‚Üí Un bug peut bloquer des heures

### üîç Debug: M√©thode Syst√©matique
1. **Reproduce**: Isoler le probl√®me (minimal test case)
2. **Validate**: V√©rifier les hypoth√®ses (disassembly, hexdump)
3. **Search**: Consulter ce document + git history
4. **Test**: Valider la fix dans QEMU
5. **Document**: Ajouter √† ce fichier si nouveau probl√®me

---

## Historique des Sessions

| Session | Probl√®me Principal | Solution | R√©f√©rence |
|---------|-------------------|----------|-----------|
| 46 | Boot failures multiples | BSS zeroing, debugcon, PIC masking | `SESSION_46_FINAL.md` |
| 47-1 | 32-bit/64-bit mismatch | boot64.S native 64-bit | `SESSION_47_BREAKTHROUGH.md` |
| 47-2 | String pointer bug (32-bit addressing) | `-mcmodel=kernel` compilation | `SESSION_47_STRING_POINTER_FIX.md` |

---

## Contribuer √† ce Document

### Quand Ajouter un Probl√®me
- Probl√®me pris > 30 minutes √† r√©soudre
- Probl√®me susceptible de se r√©p√©ter
- Solution non-√©vidente ou contre-intuitive
- Probl√®me li√© √† configuration/tooling

### Format d'Entr√©e
```markdown
### üî¥ CRITIQUE #N: Titre Court du Probl√®me

**Session**: XX
**Sympt√¥mes**:
- Comportement observable 1
- Comportement observable 2

**Cause**: Explication technique

**Solution**: Code ou commande

**Validation**: Comment v√©rifier que c'est fix√©

**R√©f√©rence**: Liens vers docs/commits
```

### Niveaux de S√©v√©rit√©
- üî¥ **CRITIQUE**: Bloque le boot ou cause data loss
- üü° **MOYEN**: Impacte fonctionnalit√© mais workaround existe
- üü¢ **FAIBLE**: Inconv√©nient mineur

---

**Derni√®re Mise √† Jour**: 2025-11-01 (Session 47)
**Maintenu par**: Claude Code + @nickywan
**Version**: 1.0
